**

# CPP Code Style

  

## 1. Общие рекомендации

  

Допускаются любые нарушения рекомендаций, если это улучшает читаемость. Основная цель — улучшение читаемости и качества кода.

  

## 2. Соглашения об именовании

  

### Стиль именования

  

- **snake_case** для переменных, функций, классов, типов

- Имена должны отражать назначение на английском языке (транслит запрещён)

- Допускаются длинные названия для ясности

- Избегать сокращений (кроме общепринятых аббревиатур: html, cpu, pe)

  

```c++

std::string file_name;

std::string user_name;

```

  

### Переменные

  

- Члены классов с префиксом `_`: `int _user_amount`

- Глобальные переменные с `::`: `::main_window.open()`

- Параметры функций с суффиксом `_`: `void set_depth(int depth_)`

- Настраиваемые переменные именуются как их тип: `void set_topic(topic_t* topic)`

- Булевые переменные/методы: `is_valid()`, `has_permission()`, избегать отрицательных форм

  

### Функции

  

- Имена от глаголов: `compute_average()`, `extract_partition_paths()`

- Методы, возвращающие списки — во множественном числе: `extract_partition_paths()`

- Избегать префиксов `get`/`set`: использовать `radius()` вместо `get_radius()`

  

### Классы и типы

  

- **snake_case** в нижнем регистре

- `struct` — только для пассивных объектов данных

- `class` — для объектов с функциональностью

- Предпочтительно `using` вместо `typedef`

- Использовать `auto` для длинных типов

  

```c++

using func_ptr = float (*)(int);

auto container = std::variant<std::string, std::uint64_t>{"Hello"};

```

  

### Перечисления

  

- **snake_case** для enum и значений

- Предпочтительно `enum class`

  

```c++

enum class fruits {

    lemon,

    kiwi

};

```

  

### Шаблоны

  

- Имена типов одной заглавной буквой: `template<class T>`

- Допускается более информативное имя: `Codec` вместо `C`

  

### Пространства имён

  

- Строчными буквами: `model::analyzer`, `io::iomanager`

  

### Файлы

  

- Строчными буквами, разделение `_`

- `.cpp` для исходников, `.hpp` для заголовков

- Специфичные имена: `http_server_logs.hpp` лучше `logs.hpp`

  

### Директива using

  

- **Допускается** для псевдонимов типов доменного слоя:

```c++

using id_t = std::uint64_t;

using fs = std::filesystem;

```

  

- **Не рекомендуется** для пространств имён: избегать `using namespace std;`

  

## 3. Комментарии

  

### Общие правила

  

- Комментировать ЧТО делает код (на уровне функций)

- Комментировать КАК работает (внутри функций)

- Комментировать ПОЧЕМУ (на уровне стейтментов)

- Использовать Doxygen-стиль

  

### Стиль комментариев

  

- `///` для документирующих комментариев

- `//` для закомментированного кода

- `/** ... */` для функций, классов, параметров

- Комментарий предваряет элемент, не следует за ним

  

### Заголовки файлов

  

```c++

/**

 * \file reader.h

 * \author github:user_name

 * \brief Краткое описание функционала

 * \date Дата создания

 * \version Версия

 */

```

  

### Комментарии к функциям

  

```c++

/**

 * \brief Краткое описание

 * \param first_ описание параметра

 * \param second_ описание параметра

 * \return описание возвращаемого значения

 * \warning предупреждения (необязательно)

 * \see ссылки (необязательно)

 */

```

  

## 4. Оформление

  

### Общие правила

  

- Ширина строки: не более 80 символов

- Стиль скобок: 1TBS (One True Bracing Style)

  

```c++

if (is_good) {

}

  

int main() {

}

```

  

### Include

  

Порядок включения:

1. Системные заголовки C (`<unistd.h>`)

2. Стандартная библиотека C++ (`<algorithm>`)

3. Заголовки других библиотек (`<fmt/format.h>`)

4. Заголовки проекта

  

Внутри секций — алфавитный порядок. Использовать абсолютные пути: `#include <project/utils/logger.hpp>`

  

### Классы и структуры

  

- Пробел после имени класса и открывающей скобки: `class person {`

- Порядок секций: `public`, `protected`, `private` (явно указаны)

- Порядок методов: конструкторы, деструктор, операторы, методы

- Список инициализации:

  

```c++

some_class(int first_, int second_):

    _size{first_},

    _value{second_}

```

  

### Циклы

  

- Однострочные циклы обрамлять фигурными скобками

- Предпочтительно range-based циклы: `for(const auto& val: arr)`

  

### Условные выражения

  

- Пробел между `if` и `(`, между `)` и `{`

- Однострочные условия обрамлять фигурными скобками

- Рекомендуется: `if (100 == some_value)` (константа слева)

- Избегать сложных условий, вводить булевы переменные

- Использовать атрибуты `[[likely]]`/`[[unlikely]]` для оптимизации

  

```c++

if (n > 0) [[likely]]

    return x * pow(x, n - 1);

else [[unlikely]]

    return 1;

```

  

### Указатели и ссылки

  

- Символы `*` и `&` без пробелов: `int* a;`, `int& a;`

- При использовании: `value_ = *some_pointer;`

  

### Логические блоки

  

- Разделять пустыми строками (не более двух подряд)

  

### Операторы

  

- Операторы обрамляются пробелами: `int a = 1;`, `bool is_good = one && two;`

  

### Функции

  

- Пробел между `)` и `{`: `int main() {`

- Пробел после запятой: `void calc(int first_, int second_);`

- Параметры с суффиксом `_`: `int first_`

- Длинные профили переносить:

  

```c++

double resolve(

    const ip::v4 dns_server_address,

    const std::string_view host)

```

  

### Возвращаемое значение

  

- Предпочтительно возвращаемое значение, не выходные параметры

- Для результата + ошибка: `std::tuple<person, std::error_code>` (результат первым)

- Булевые функции: `std::tuple<bool, std::error_code>`

  

### Размер функций

  

- Желательно до 40 строк, при превышении — рассмотреть разбиение

  

### Параметры

  

- Параметры по ссылке должны быть `const`

  

### noexcept

  

- Обязательно явно указывать: `noexcept` или `noexcept(false)`

  

### const

  

- Использовать `const` в методах, не изменяющих состояние объекта

  

### Пространства имён

  

- Размещать код в пространстве имён

- В конце добавлять комментарий: `}  // namespace mynamespace`

- Не использовать `using namespace`

  

### Шаблоны

  

- `template` и параметры на отдельной строке:

  

```c++

template<typename T, typename C>

void func(...)

```

  

- Допускается пробелы в типах: `std::vector< int >`

  

### Приведение типов

  

- Использовать C++-стиль: `static_cast<float>(double_value)`

- Избегать C-стиля

  
**