
# Тестовое задание для C++ разработчика 

## Введение

Данное тестовое задание предназначено для оценки кандидатов на позицию C++ разработчика.
  
Задание проверяет навыки работы с современным C++23, обработкой данных, файловой системой и библиотеками Boost.
  
**Цель задания:** Разработать консольное приложение для расчета медианы цен из CSV-файлов с потоковыми данными биржевых торгов.

---
## 1. Описание задачи

### 1.1. Общая задача  

Вам предстоит создать консольное приложение для анализа биржевых данных. Приложение читает файлы с историей торгов, вычисляет медиану цен по мере обработки данных и сохраняет результаты в выходной файл.

Суть задачи: По мере чтения каждой новой цены из файлов, программа пересчитывает медиану с учетом всех ранее прочитанных значений. Когда медиана изменяется — приложение фиксирует это в результирующем файле вместе с временной меткой.  

Ключевая особенность: Медиана рассчитывается постепенно, добавляя по одному значению. Например: прочитали цену 100 → медиана 100; добавили цену 102 → медиана 101; добавили цену 99 → медиана 100. Каждое новое значение учитывает все предыдущие, а не вычисляется заново по всему набору данных.

### 1.2. Входные данные

Приложение читает CSV-файлы из указанной директории. Каждый файл представляет определенный тип биржевых данных.  

> В рамках данной задания необходимо самостоятельно сгенерировать входные данные, например с помощью LLM

#### Структура файла `level.csv`:  

> **Примечание:** Разделитель колонок — точка с запятой (`;`).

```csv

receive_ts;exchange_ts;price;quantity;side;rebuild

1716810808593627;1716810808574000;68480.00000000;10.10900000;bid;1

1716810808593627;1716810808574000;68479.90000000;0.00400000;bid;0

1716810808593627;1716810808574000;68480.20000000;4.52800000;ask;0

1716810808593627;1716810808574000;68480.40000000;0.10200000;ask;0

```

  

**Описание полей:**

- `receive_ts` — временная метка получения данных (микросекунды)
- `exchange_ts` — временная метка биржи (микросекунды)
- `price` — цена
- `quantity` — объем
- `side` — сторона (`bid` или `ask`)
- `rebuild` — флаг перестроения стакана (0 или 1)

#### Структура файла `trade.csv`:  

```csv

receive_ts;exchange_ts;price;quantity;side

1716810808663260;1716810808661000;68480.10000000;0.01100000;bid

1716810809314641;1716810809312000;68480.00000000;0.00200000;ask

1716810809719209;1716810809717000;68480.10000000;0.00500000;bid

1716810809719209;1716810809717000;68480.10000000;0.00200000;bid

1716810809719209;1716810809717000;68480.10000000;0.16900000;bid

```

**Описание полей:**

- `receive_ts` — временная метка получения данных (микросекунды)
- `exchange_ts` — временная метка биржи (микросекунды)
- `price` — цена сделки
- `quantity` — объем сделки
- `side` — сторона (`bid` или `ask`)
### 1.3. Выходные данные

Приложение создает CSV-файл с двумя колонками:

```csv

receive_ts;price_median

1716810808663260;68480.10000000

1716810809314641;68480.05000000

1716810809719209;68480.10000000

```  

**Описание полей:**

- `receive_ts` — временная метка события, которое изменило медиану
- `price_median` — значение медианы, рассчитанное на основе всех цен, считанных до этого момента
  
**Важно:** В выходной файл записывается строка **только при изменении значения медианы**.  

---
## 2. Конфигурация приложения

### 2.1. Параметры командной строки  

Приложение принимает путь к конфигурационному файлу через следующие аргументы:


```bash

./csv_median_calculator -config /path/to/config.toml

# или

./csv_median_calculator -cfg /path/to/config.toml

```

**Поддерживаемые аргументы:** `-cfg`, `-config`

Если аргумент не указан, приложение ищет файл `config.toml` в той же директории, где находится исполняемый файл.  

### 2.2. Формат конфигурационного файла

Конфигурация задается в формате TOML:  

```toml

[main]

    # Путь к директории с входными CSV-файлами

    input = '/path/to/input_dir'

    # Путь к директории для выходных CSV-файлов

    # Если не указан, создается директория 'output' рядом с приложением

    output = '/path/to/output_dir'

    # Список масок имен файлов для фильтрации

    # Если список пустой, читаются все CSV-файлы из директории

    filename_mask = ['level', 'trade']

```

  
**Параметры:**

- `input` (обязательный) — путь к директории с входными CSV-файлами
- `output` (опциональный) — путь к директории для выходных файлов. Если не указан, создается директория `output` в текущей рабочей директории
- `filename_mask` (опциональный) — список строк для фильтрации имен файлов. Читаются только те файлы, имена которых содержат хотя бы одну из указанных масок. Если список пустой, читаются все CSV-файлы
  

---

## 3. Алгоритм работы приложения

### 3.1. Общий алгоритм

1. **Парсинг аргументов командной строки** с использованием `Boost.Program_options`
2. **Чтение и валидация конфигурационного файла** (формат TOML)
3. **Сканирование файловой системы**: поиск CSV-файлов в указанной директории с применением фильтров из `filename_mask`
4. **Чтение и объединение данных**: считывание всех подходящих CSV-файлов
5. **Сортировка данных** по полю `receive_ts` (временная метка)
6. **Инкрементальный расчет медианы**:
   - Поочередная обработка каждой записи
   - Добавление цены в структуру данных для расчета медианы
   - Вычисление текущей медианы с использованием `Boost.Accumulators`
   - Запись результата при изменении медианы
1. **Запись результатов** в выходной CSV-файл

### 3.2. Расчет медианы

> **Медиана** — это значение, которое делит упорядоченный набор данных пополам. Для четного количества элементов медиана рассчитывается как среднее арифметическое двух центральных значений.  

Основная задача приложения — расчет медианы цены в каждый момент времени на основе всех ранее считанных значений цены.

**Ключевое требование:** Медиана должна рассчитываться **инкрементально**. 

На каждом шаге обработки:

- Добавляется новое значение цены из текущей записи
- Вычисляется медиана на основе **всех** значений, обработанных с начала работы
- Если медиана изменилась по сравнению с предыдущим значением, записывается новая строка в выходной файл

**Пример:**  

```

Шаг 1: price=68480.10, медиана=68480.10 → запись в файл

Шаг 2: price=68480.00, медиана=68480.05 → запись в файл  

Шаг 3: price=68480.10, медиана=68480.10 → запись в файл

Шаг 4: price=68480.10, медиана=68480.10 → медиана не изменилась, запись НЕ производится

```


---
## 4. Технические требования
  
### 4.1. Обязательные требования

1. **Язык и стандарт:** C++23
2. **Система сборки:** CMake (минимальная версия 3.23)
3. **Подключение зависимостей:** через `FetchContent`
4. **Code style:** Мы понимаем что к новому code-style необходимо привыкнуть, поэтому требование писать по нашему code-style необязательное, но возможно Вы сами захотите поработать с ним.
5. **Conventional Commits:** Все коммиты должны соответствовать [спецификации](https://www.conventionalcommits.org/ru/v1.0.0/), на русском языке
### 4.2. Обязательные библиотеки

| Библиотека              | Назначение                          | Ссылка                                                                          |
| ----------------------- | ----------------------------------- | ------------------------------------------------------------------------------- |
| `Boost.Program_options` | Парсинг аргументов командной строки | [Boost](https://www.boost.org/)                                                 |
| `Boost.Accumulators`    | Расчет медианы                      | [Boost Accumulators](https://www.boost.org/doc/libs/release/libs/accumulators/) |
| `toml++`                | Парсинг TOML конфигурации           | [toml++](https://github.com/marzer/tomlplusplus)                                |
| `spdlog`                | Логирование                         | [spdlog](https://github.com/gabime/spdlog)                                      |

### 4.3. Стандартные библиотеки C++

- `std::filesystem` — для работы с файловой системой
- `std::format` — для форматирования строк и логирования
- `std::ranges` — для обработки данных (опционально)

### 4.4. Требования к качеству кода

#### Обработка ошибок:

- Приложение **не должно аварийно завершаться** (crash) при любых входных данных
- Все ошибки должны обрабатываться gracefully
- Отсутствие параметров конфигурации → ошибка с информативным сообщением
- Проблемы с файловой системой → ошибка с информативным сообщением
- Некорректный формат CSV → ошибка с указанием файла и строки
- Корректная обработка отсутствующих файлов или директорий
- Валидация формата входных данных (CSV)
- Обработка некорректных числовых значений
- Обработка пустых файлов
- Обработка файлов с некорректным форматом данных
- Обработка отсутствующих колонок в CSV
  

#### Логирование:

- Все ошибки и важные события должны логироваться через `spdlog`
- Форматирование сообщений: `std::format` (C++20/23)

#### Комментарии:

- Сложные участки кода должны быть прокомментированы
- Комментарии должны объяснять **"зачем"**, а не **"что"** делает код
- **Не требуется** комментировать каждую строку кода

#### Производительность:

- Приложение должно быть написано с учетом максимальной скорости работы
- Минимизировать копирование данных
- Использовать эффективные структуры данных
- Избегать лишних аллокаций памяти

### 4.5. Документация

Приложение должно включать файл `README.md` со следующими разделами:

1. **Описание приложения** — краткое описание функциональности
2. **Требования** — список зависимостей и системных требований
3. **Сборка проекта** — инструкции по сборке с CMake
4. **Запуск приложения** — примеры использования с параметрами
5. **Формат конфигурации** — описание всех параметров конфигурационного файла
6. **Примеры** — примеры входных и выходных данных

---

## 5. Пример использования

### 5.1. Структура проекта  

```

csv_median_calculator/

├── CMakeLists.txt
├── README.md
├── src/
│   ├── main.cpp
│   ├── config_parser.hpp
│   ├── csv_reader.hpp
│   ├── median_calculator.hpp
│   └── ...
├── config.toml
└── examples/
    ├── input/
    │   ├── btcusdt_level_2024.csv
    │   └── btcusdt_trade_2024.csv
    └── output/
        └── median_result.csv

```

### 5.2. Пример запуска

```bash
# Сборка проекта

cmake -S . -B build -DCMAKE_BUILD_TYPE=Release

cmake --build build

# Запуск с конфигурацией

./build/csv_median_calculator -config config.toml

# Запуск с конфигурацией по умолчанию (config.toml в той же директории)

./build/csv_median_calculator
```

### 5.3. Пример вывода в консоль

```

[2024-10-31 12:00:00.123] [info] Запуск приложения csv_median_calculator v1.0.0

[2024-10-31 12:00:00.125] [info] Чтение конфигурации: config.toml

[2024-10-31 12:00:00.130] [info] Входная директория: /data/input

[2024-10-31 12:00:00.131] [info] Выходная директория: /data/output

[2024-10-31 12:00:00.135] [info] Найдено файлов: 2

[2024-10-31 12:00:00.136] [info]   - btcusdt_level_2024.csv

[2024-10-31 12:00:00.136] [info]   - btcusdt_trade_2024.csv

[2024-10-31 12:00:00.500] [info] Прочитано записей: 150000

[2024-10-31 12:00:00.650] [info] Записано изменений медианы: 45230

[2024-10-31 12:00:00.651] [info] Результат сохранен: /data/output/median_result.csv

[2024-10-31 12:00:00.651] [info] Завершение работы

```

___

## Примеры использования приложения

### Пример 1: Базовая конфигурация

**Конфигурация (`config.toml`):**

```toml
[main]

    input = './data'

    output = './results'

    filename_mask = ['trade']
```

**Запуск:**

```bash
./app --config config.toml
```

**Результат:**

- Обрабатываются только файлы с `trade` в имени из директории `./data`
- Результаты сохраняются в директорию `./results`
### Пример 2: Обработка всех файлов

**Конфигурация (`config.toml`):**

```toml
[main]

    input = '/var/data/market'

    output = '/var/results'

    filename_mask = []
```

**Запуск:**

```bash
./app --config config.toml
```

**Результат:**

- Обрабатываются все CSV файлы из директории `/var/data/market`
- Результаты сохраняются в директорию `/var/results`

### Пример 3: Без указания выходной директории

**Конфигурация (`config.toml`):**

```toml
[main]

    input = './data'

    filename_mask = ['level', 'trade']
```

**Запуск:**

```bash
./app --config config.toml
```

**Результат:**

- Обрабатываются файлы с `level` или `trade` в имени
- Создается директория `output` в текущей директории
- Результаты сохраняются в `./output`

### Пример 4: Обработка данных с несколькими временными метками

**Входные данные (`trade.csv`):**

```csv
receive_ts;exchange_ts;price;quantity;side

1000;900;100.0;1.0;bid

2000;1900;101.0;2.0;ask

2000;1900;102.0;1.5;bid

3000;2900;103.0;3.0;ask
```


**Расчет медианы:**

1. `receive_ts = 1000`, `price = 100.0`
   - Значения: `[100.0]`
   - Медиана: `100.0`
1. `receive_ts = 2000`, `price = 101.0`
   - Значения: `[100.0, 101.0]`
   - Медиана: `(100.0 + 101.0) / 2 = 100.5`
1. `receive_ts = 2000`, `price = 102.0`
   - Значения: `[100.0, 101.0, 102.0]`
   - Медиана: `101.0`

1. `receive_ts = 3000`, `price = 103.0`
   - Значения: `[100.0, 101.0, 102.0, 103.0]`
   - Медиана: `(101.0 + 102.0) / 2 = 101.5`

**Выходной файл (`result.csv`):**

```csv
receive_ts;price_median

1000;100.0

2000;100.5

2000;101.0

3000;101.5
```  
  

---  

## 6. Критерии оценки

### 6.1. Обязательные критерии (должны быть выполнены все)  

- ✅ Приложение собирается без ошибок с CMake

- ✅ Корректно работает парсинг аргументов командной строки

- ✅ Корректно читается и валидируется конфигурационный файл TOML

- ✅ Правильно работает фильтрация файлов по маскам

- ✅ Корректно считываются CSV-файлы

- ✅ Правильно рассчитывается инкрементальная медиана

- ✅ Корректно формируется выходной файл

- ✅ Приложение обрабатывает ошибки без падений

- ✅ Присутствует логирование с разными уровнями

- ✅ Есть файл README.md с документацией

### 6.2. Дополнительные критерии (повышают оценку)

#### Code Quality:

- Использование современных возможностей C++23
- Применение RAII и умных указателей
- Const-correctness
- Отсутствие утечек памяти
- Чистый и читаемый код
#### Architecture:

- Модульная структура кода
- Разделение на логические компоненты
- Возможность расширения функциональности
#### Performance:

- Эффективное использование памяти
- Минимизация копирований
- Быстрая обработка больших файлов (>100MB)
#### Testing:

- Наличие unit-тестов (например, с Catch2)
- Проверка корректности расчета медианы
- Тесты обработки ошибок
  
---

## 7. Бонусные задания (опционально)

Выполнение этих заданий не обязательно, но значительно повышает оценку кандидата.

### 7.1. Многопоточная обработка  

Реализовать параллельное чтение и обработку нескольких CSV-файлов с последующим merge результатов по временной метке.

**Требования:**
- Использовать стандартные средства многопоточности C++
- Обеспечить потокобезопасность
- Измеримое ускорение на больших объемах данных

### 7.2. Различные типы агрегации

Добавить возможность расчета других метрик помимо медианы:
- Среднее значение (mean)
- Стандартное отклонение (std deviation)
- Квантили (percentiles): p50, p90, p95, p99

**Требования:**
- Параметризация через конфигурацию
- Использование `Boost.Accumulators` для всех метрик
  
### 7.3. Потоковая обработка больших файлов

Оптимизировать приложение для работы с файлами, не помещающимися в оперативную память.

**Требования:**
- Использовать потоковую обработку (streaming)
- Минимизировать использование памяти
- Сохранить корректность расчета медианы

---
  
## 8. Срок выполнения и формат сдачи

### 8.1. Формат сдачи

1. **GitHub/GitLab репозиторий** с исходным кодом
2. Видео-демонстрация работы приложения с звуком и вашим представлением проекта
### 8.2. Что мы будем проверять

1. Клонируем репозиторий
2. Собираем проект согласно инструкциям в README.md
3. Запускаем приложение на тестовых данных
4. Проверяем корректность результатов
5. Анализируем код на соответствие требованиям
6. Оцениваем quality и architecture  


  
